Lug Raffle Protocol:
^^^^^^^^^^^^^^^^^^^^

The main goal of this protocol is to form a good base on which a project can
be built that is sufficiently intricate that it can be worked on by people
with different skill-sets and interests.  It does not have a goal of being
the best possible raffling mechanism or solving the problem simply.  Another
goal of this protocol is to create a fully distributed protocol for
managing the raffling of real-world items.  It is distributed to avoid the
requirement of a central computer that everyone must use to enter raffling
information (which would result in it not being used for anything else).
Another goal is to distribute the drawing operation of the raffle so that it
can not easily be rigged by anyone.  With that said, there are definitely flaws
and omissions in this protocol.  We've decided to push a lot of things off to
"version 2", which may or may not ever actually happen.  :o)

All messages are sent as broadcasts on the local network on UDP port 1234.
There are currently 6 different packet types.  The whole process starts by a
machine sending out RAFFLE_NODE_DISCOVER packets.  These are packets that just
ask the network if there are any other nodes running LRP.  Any other nodes
that are running LRP will reply with a RAFFLE_NODE_FOUND packet.  The
RAFFLE_NODE_FOUND packet lets other nodes know about the existence of the
sending node.  It also contains all of the data currently stored by this LRP
session (all of the items and entries).  Before a node has discovered any
other nodes it will continue to send out a RAFFLE_NODE_DISCOVER packet every
10 seconds.  Once a node has discovered at least one other node it will no
longer send out DISCOVER packets, but it will still reply to DISCOVER packets
with FOUND packets.

When an item is added to the system for raffling or a person would like to
be entered in to the raffle for an item a RAFFLE_OBJECT_ADD packet is sent out
by the node that collected the data from the user.  This is how all of the
other nodes will find out about the new item or entry.

The drawing process is perhaps a little more complicated than we would like it
to be, but we really tried to make it difficult for it to be rigged by anyone
at all.  Admittedly, raffling off a book is less serious than, say, electing a
government official, but this is all for fun so we went for it.  It should be
noted that anyone can innitiate a drawing at any time, but only the official
drawing at the end of the night is respected.  This is the same as the paper
raffles in that anyone can go up to the papers at any time, randomly select
one, and see who the 'winner' was.  But, that winner does not actually get the
item.  The drawing process is started when a node sends out a
RAFFLE_DRAWING_START packet.  When a node receives the DRAWING_START packet
it will choose a random 32-bit integer and store it locally.  It will generate
the sha1 hash for that integer and send the hash out on to the network in a
RAFFLE_DRAWING_RESPONSE_HASH packet.  All nodes will send out this packet,
including the node that sent the START packet.  Nodes receiving the HASH
packet will remember the hash that was received from each node.  After all
nodes on the network have sent out HASH packets, they will start sending out
their RESPONSE packets.  These RESPONSE packets contain the random 32-bit
integer that they chose randomly.  All nodes will receive this RESPONSE packet
and verify that the number received produces the same hash that was sent out
in the RESPONSE_HASH packet.  By doing this HASH/RESPONSE maneuver we make the
nodes commit to a random number before they know all of the other nodes'
random numbers.  Without this it is possible that the last node to send in its
number could rig the drawing.

At this point every node will have every other nodes' random integer.  The
following process will combine all of this randomness and choose a winner for
every item in the raffle.  The random numbers are combined by XORing them
together.  The nodes then loop over all of the items that are being raffled.
The winning item is the one in the array with the index that is produced by
modding the XORed collection with the number of people in the raffle for that
item.  Before moving on to the next item the XORed number is modified by
adding the result of the mod to it.  This is done because without it the same
entry will be chosen for every item if they have the same number of entries.

This process is defined in the pseudo code below:

xor_result = XOR of all nodes' integers together
for X in items.len():
	items[X].entries = (n0, n1, n2, n3, n4)
	winning_index = xor_result % item[X]entries.len()
	xor_result += winning_index

After the node has figured out the collection of winners it sends them out
in a RAFFLE_DRAWING_RESULT packet.  This way every other node can verify the
result generated by every other node.  Only if all of the nodes come up with
the same result should the drawing be trusted.  If any node detects a problem
it should notify the user because the drawing is bogus.

The packet format for Lug Raffle Protocol 1:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Everything in this protocol is sent as ASCII text.

MAGIC 4 CHAR STRING: LRP1 (Lug Raffle Protocol 1)

Packet Types:
00 RAFFLE_NODE_DISCOVER
01 RAFFLE_NODE_FOUND
10 RAFFLE_OBJECT_ADD
20 RAFFLE_DRAWING_START
21 RAFFLE_DRAWING_RESPONSE_HASH
22 RAFFLE_DRAWING_RESPONSE
23 RAFFLE_DRAWING_RESULT

Object Types:
0 ITEM
1 NAME/ITEM PAIR

Packet:
4 bytes magic
2 bytes command
semicolon
payload length in ascii (not counting next semicolon)
semicolon
<payload>

Examples:
LRP100;0;
LRP101;45;0;13;Mark's Laptop;1;13;Mark's Laptop;4;Jeff;
LRP110;24;1;Mark's Laptop;5;Chris;
LRP120;0;
LRP121;41;0123456789abcdef0123456789abcdef01234567;
LRP122;7;123456;
LRP123;27;1;13;Mark's Laptop;5;Chris;

